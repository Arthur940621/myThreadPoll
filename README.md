# `C++` 中有关线程的库

[chrono](./note/chrono.md)

[thread](./note/thread.md)

[mutex](./note/mutex.md)

[condition_variable](./note/condition_variable.md)

[future](./note/future.md)

[atomic](./note/atomic.md)

# 线程池

## 线程池原理

我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。打个比方：

阶段一：

一个医院，每天面对成千上万的病人，处理方式是：来一个病人找来一个医生处理，处理完了医生也走了。当看病时间较短的时候，医生来去的时间，显得尤为费时了。

阶段二：

医院引进了线程池的概念。设置门诊，把医生全派出去坐诊，病人来看病先挂号排队，医生根据病人队列顺序依次处理各个病人，这样就省去医生来来去去的时间了。但是，很多时候病人不多，医生却很多导致很多医生空闲浪费水电资源撒。

阶段三：

医院引进了可伸缩性线程池的概念，如阶段二，但是门诊一开始只派出了部分医生，但是增加了一个领导，病人依旧是排队看病，领导负责协调整个医院的医生。当病人很多医生忙不过来的时候，领导就去多叫几个医生来帮忙；当病人不多医生太多的时候，领导就叫一些医生回家休息去免得浪费医院资源。

阶段三就是一个线程池的例子。

## 线程池实现

[ThreadPool](./src/ThreadPool.hpp)

# 使用方法

```cpp
#include "ThreadPool.hpp" // 包含头文件

ThreadPool pool(th_count); // 初始化线程池

pool.commit(func, args...); // 提交线程任务函数和参数
```